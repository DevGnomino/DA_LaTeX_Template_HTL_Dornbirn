\subsection{Einlesen der Konfigurationsdateien}
\paragraph{Klassenstruktur}
Im Backend (falls man es so nennen kann) wird die Klassenstruktur der \acs{gui} nachgebildet. Es gibt eine Page-, Measurement- und Sensorklasse. Die Pages und Measurements existieren, damit der ausgelesene Parameter einfach an der richtigen Stelle verändert werden kann. Ein Measurement kann mehrere Sensoren enthalten, da manche Measurements zur Berechnung  (z.B. der Wärmerückgewinnungsgrad) mehrere Messwerte benötigen (siehe Abb.~\ref{fig:uml_backend}).
\begin{figure}[ht]
	\centering
	\includegraphics[width=1.0\linewidth]{Bilder/UML_Backend}
	\caption{UML Diagramm Backend}
	\label{fig:uml_backend}
\end{figure}

Die Page-, Measurement- und Sensorobjekte werden beim Einlesen der Konfigurationsdateien aufgrund des \enquote{pages} JSON Objekts erstellt und in Listen gespeichert. \newline
Zum Einlesen werden drei Funktionen benötigt:
\begin{itemize}
	\item \textbf{\enquote{load\_config}:} Diese Funktion lädt die gesamte Hauptkonfigurationsdatei ein. Es werden die angeschlossenen Geräte ermittelt und die Page-, Measurement- und Sensorobjekte erstellt. Außerdem kommen die beiden folgenden Hilfsfunktionen zum Einsatz.
	\item \textbf{\enquote{get\_sensor\_unit}:} Liest die Sensor-Konfigurationsdateien ein. Dadurch können den Messwerten die richtigen Maßeinheiten zugewiesen werden.
	\item \textbf{\enquote{get\_sensor\_data}:} Liest aus der Geräte-Konfigurationsdatei am angegebenen Port die Parameter aus und liefert diese Parameter als JSON Objekt zurück. Sie liest das Register, den Function Code und die Skalierung aus. Die Skalierung wird anhand der Maßeinheit aus der Sensor-Konfigurationsdatei ausgewählt.
\end{itemize}

\paragraph{Einlesen und erstellen der Objektstruktur}
Einlesen kann man ein JSON Attribut mit folgender Syntax. Im folgenden Beispiel wird aus dem Objekt namens page das Attribut title gesucht und zurückgeliefert.
\begin{pythoncode}
title = page["title"]
\end{pythoncode}

Im folgenden Code werden die Measurements erstellt, indem die anzuzeigenden Messwerte aus dem Sources Array iteriert werden. Anhand der Informationen im Sources Array werden dann die entsprechenden Geräte im Devices Array herausgesucht. Es werden weitere Parameter aus der Hauptkonfiguration ausgelesen, die zu dem entsprechenden Messwert gehören (z.B. die Beschreibung oder die Einheit). Anschließend werden die Sensorobjekte erstellt (Verweis auf nächsten Codeblock) und einer Liste beigefügt, da manche Measurements mehrere Messwerte benötigen. Diese Liste, sowie die vorher ausgelesenen Parameter werden beim Erstellen der Measurement Objekte dem Konstruktor übergeben und darin in Instanzvariablen gespeichert.
\begin{pythoncode}
page_measurements = []
for measurements in page["sources"]:
	page_sensors = []
	[Auslesen weiterer Parameter der Hauptkonfigurationsdatei (description, unit, python_function,additional_info)]
	[Erstellen der Sensorobjekte (Verweis auf nächsten Codeblock)]
	page_measurements.append(Measurement(description=description, unit=unit, sensors=page_sensors, python_function=python_function, additional_info=additional_info))
\end{pythoncode}

Im folgenden Code wird für jeden Port (muss ich das erklären?: an jedem Port ist ein Sensor angeschlossen) eines Geräts ein Sensorobjekt erstellt. Alle Sensorobjekte werden der \enquote{page\_sensors} Liste beigefügt. Dafür gibt es im Sources Array die einzelnen Ports. Das sind Wertepaare, die aus Gerät und Sensor bestehen (vgl. Kapitel damio). Mit diesen beiden Werten kann dann das entsprechende Gerät im Devices Array gefunden werden und darin der entsprechende Port im Sensors Array.
\begin{pythoncode}
for port in port_arr:
	device_id = list(port.keys())[0]  # example: QBM1
	port_id = port[device_id]
	
	for device in config_full_data[0]["devices"]:
		if device["id"] == device_id:
			[Aufruf der get\_sensor\_unit Funktion]
			[Auslesen der Geräteparameter in der Hauptkonfigurationsdatei (baud_rate, mbaddress etc.)]
			[Aufruf der get\_sensor\_data Funktion]
			page_sensors.append(Sensor(baud_rate=baud_rate, mb_address=mbaddress, parity=parity, stop_bits=device["stop_bits"], register=register, scaling=scaling, function_code=function_code, zero_based=device["zero_based"]))	
\end{pythoncode}

Die Measurements sind nach dem Erstellen alle in einer Liste gespeichert. Zum Schluss werden Pageobjekte erstellt. Die Measurements Liste wird so aufgeteilt, dass maximal 5 Measurements auf einer Seite sind. Anhand von diesen Page- und Measurement Objekten wird beim Erstellen der \acs{gui} die Anzahl an Seiten übernommen und der Seitentitel und die Beschreibungen der Messwerte gesetzt (siehe Kapitel GUI beschreibung). 
\begin{pythoncode}
counter = 0
last_slice = 0
for measurement in page_measurements:
	counter += 1
	if ((counter \% 5) == 0) or (counter == len(page_measurements)):
		all_pages.append(Page(title=title, measurements=page_measurements[last_slice:counter]))
		last_slice = counter
\end{pythoncode}

%\pythonfile[firstline=125, lastline=197]{Code/modbus.py}

\begin{pythoncode}
def get_sensor_data(device_full_data, port_name, sensor_unit):
	for device in device_full_data["ports"]:
	print(device)
	if device["port"] == port_name:
	print("in port if")
	sensor_register = device["register"]
	sensor_function_code = device["function_code"]
	if "units" in device:
	for unit_pair in device["units"]:  # Hier kann vielleicht später das Array anders entpackt werden (mit *)
	if unit_pair["unit"] == sensor_unit:
	sensor_scaling = unit_pair["scaling"]
	return_var = {"sensor_register": sensor_register, "sensor_scaling": sensor_scaling,
		"sensor_function_code": sensor_function_code}
	return return_var
	else:
	return_var = {"sensor_register": sensor_register, "sensor_scaling": 1,
		"sensor_function_code": sensor_function_code}
	return return_var
	
	
	return -1
	
	
def get_sensor_unit(sensor_name):
	sensor_file = open(DEVICES_CONFIG_PATH + 'sensors.json', encoding='utf-8')
	sensor_full_data = json.load(sensor_file)
	# print(sensor_full_data)
	for sensor in sensor_full_data:
	if sensor["type"] == sensor_name:
	sensor_unit = sensor["unit"]
	return sensor_unit
	
	sensor_file.close()
	return ""
\end{pythoncode}

Im Konstruktor der Page- Measurement- und Sensorobjekte werden die ausgelesenen Variablen in Instanzvariablen gespeichert.


!Im entsprechenden Sensor gespeichert!