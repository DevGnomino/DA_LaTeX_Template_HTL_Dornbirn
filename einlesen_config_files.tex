\subsection{Einlesen der Konfigurationsdateien}
!Klassenstruktur beschreiben + UML-Diagramm; den ganzen code dazu weglassen --> weil sehr viel - UML struktur im GUI schon beschrieben; also hier kurz halten; vlt gui section vor config dateien verschieben!

Im Backend (falls man es so nennen kann) wird die Klassenstruktur der \acs{gui} nachgebildet. Es gibt eine Page-, Measurement- und Sensorklasse. Die Pages und Measurements existieren, damit der ausgelesene Parameter einfach an der richtigen Stelle verändert werden kann. Ein Measurement kann mehrere Sensoren enthalten, da manche Parameter zur Berechnung  (z.B. der Wärmerückgewinnungsgrad) mehrere Messwerte benötigen. \newline 
Die Page-, Measurement- und Sensorobjekte werden beim Einlesen der Konfigurationsdateien aufgrund des \enquote{pages} JSON Objekts erstellt und in Listen gespeichert. \newline
Zum Einlesen werden drei Funktionen benötigt:
\begin{itemize}
	\item \textbf{\enquote{load\_config}:} Diese Funktion lädt die gesamte Hauptkonfigurationsdatei ein. Es werden die angeschlossenen Geräte und die angezeigte GUI erstellt. Außerdem kommen die beiden folgenden Hilfsfunktionen zum Einsatz.
	\item \textbf{\enquote{get\_sensor\_data}:} 
	\item \textbf{\enquote{get\_sensor\_unit}:} Liest die \enquote{sensor} Konfigurationsdatei ein. Dadurch können die richtigen Messeinheiten zugewiesen werden.
\end{itemize}

Einlesen kann man ein JSON Attribut mit folgendem Syntax. Hierbei wird aus dem page Objekt das Attribut title gesucht und zurückgeliefert.
\begin{pythoncode}
title = page["title"]
\end{pythoncode}

Erstellen Measurements
\begin{pythoncode}
page_measurements = []
for measurements in page["sources"]:
page_sensors = []
[Auslesen JSON Datei]
[Erstellen Sensorobjekte]
page_measurements.append(Measurement(description=description, unit=unit, sensors=page_sensors, python_function=python_function, additional_info=additional_info))
\end{pythoncode}

Auslesen der Sensordaten. Für jedes Gerät wird ein neues Sensor Objekt erstellt und der Sensorliste.
\begin{pythoncode}
for port in port_arr:
	device_id = list(port.keys())[0]  # example: QBM1
	
	for device in config_full_data[0]["devices"]:
		if device["id"] == device_id:
			[Auslesen Konfigurationsdateien]
			page_sensors.append(Sensor(baud_rate=device["baud_rate"], mb_address=device["mbaddress"], parity=device["parity"], stop_bits=device["stop_bits"], register=register, scaling=scaling, function_code=function_code, zero_based=device["zero_based"]))	
\end{pythoncode}

Die Measurements werden aufgeteilt, damit maximal 5 Measurements auf einer Seite sind. 
\begin{pythoncode}
counter = 0
last_slice = 0
for measurement in page_measurements:
	counter += 1
	if ((counter \% 5) == 0) or (counter == len(page_measurements)):
		all_pages.append(Page(title=title, measurements=page_measurements[last_slice:counter]))
		last_slice = counter
\end{pythoncode}

%\pythonfile[firstline=125, lastline=197]{Code/modbus.py}

\begin{pythoncode}
def get_sensor_data(device_full_data, port_name, sensor_unit):
	for device in device_full_data["ports"]:
	print(device)
	if device["port"] == port_name:
	print("in port if")
	sensor_register = device["register"]
	sensor_function_code = device["function_code"]
	if "units" in device:
	for unit_pair in device["units"]:  # Hier kann vielleicht später das Array anders entpackt werden (mit *)
	if unit_pair["unit"] == sensor_unit:
	sensor_scaling = unit_pair["scaling"]
	return_var = {"sensor_register": sensor_register, "sensor_scaling": sensor_scaling,
		"sensor_function_code": sensor_function_code}
	return return_var
	else:
	return_var = {"sensor_register": sensor_register, "sensor_scaling": 1,
		"sensor_function_code": sensor_function_code}
	return return_var
	
	
	return -1
	
	
def get_sensor_unit(sensor_name):
	sensor_file = open(DEVICES_CONFIG_PATH + 'sensors.json', encoding='utf-8')
	sensor_full_data = json.load(sensor_file)
	# print(sensor_full_data)
	for sensor in sensor_full_data:
	if sensor["type"] == sensor_name:
	sensor_unit = sensor["unit"]
	return sensor_unit
	
	sensor_file.close()
	return ""
\end{pythoncode}

Im Konstruktor der Page- Measurement- und Sensorobjekte werden die ausgelesenen Variablen in Instanzvariablen gespeichert.


!Im entsprechenden Sensor gespeichert!