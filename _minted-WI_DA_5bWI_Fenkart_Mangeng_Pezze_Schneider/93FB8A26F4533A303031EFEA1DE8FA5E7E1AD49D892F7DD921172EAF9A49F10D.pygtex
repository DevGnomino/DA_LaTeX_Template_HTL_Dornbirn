\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{CONFIG\PYGZus{}PATH} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}/home/pi/Documents/RLT\PYGZus{}Config/\PYGZsq{}}
\PYG{n}{DEVICES\PYGZus{}CONFIG\PYGZus{}PATH} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}/home/pi/Documents/RLT\PYGZus{}Config/devices/\PYGZsq{}}

\PYG{k}{class} \PYG{n+nc}{Sensor}\PYG{p}{():}
	\PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{baud\PYGZus{}rate}\PYG{p}{,} \PYG{n}{mb\PYGZus{}address}\PYG{p}{,} \PYG{n}{parity}\PYG{p}{,} \PYG{n}{stop\PYGZus{}bits}\PYG{p}{,} \PYG{n}{scaling}\PYG{p}{,} \PYG{n}{register}\PYG{p}{,} \PYG{n}{function\PYGZus{}code}\PYG{p}{,} \PYG{n}{zero\PYGZus{}based}\PYG{p}{):}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{scaling} \PYG{o}{=} \PYG{n}{scaling}
		\PYG{k}{if} \PYG{n}{zero\PYGZus{}based}\PYG{p}{:}
			\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{register} \PYG{o}{=} \PYG{n}{register}
		\PYG{k}{else}\PYG{p}{:}
			\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{register} \PYG{o}{=} \PYG{n}{register} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{function\PYGZus{}code} \PYG{o}{=} \PYG{n}{function\PYGZus{}code}
\PYG{+w}{		}
\PYG{+w}{		}\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}print(\PYGZdq{}Register\PYGZdq{},register)}
\PYG{l+s+sd}{		print(\PYGZdq{}baudrate\PYGZdq{},baud\PYGZus{}rate)}
\PYG{l+s+sd}{		print(\PYGZdq{}mbaddress\PYGZdq{},mb\PYGZus{}address)}
\PYG{l+s+sd}{		print(\PYGZdq{}functioncode\PYGZdq{},function\PYGZus{}code)}
\PYG{l+s+sd}{		print(\PYGZdq{}zerobased\PYGZdq{},zero\PYGZus{}based)}
\PYG{l+s+sd}{		print(\PYGZdq{}parity\PYGZdq{},parity)\PYGZdq{}\PYGZdq{}\PYGZdq{}}
		
		\PYG{c+c1}{\PYGZsh{} Mit USB Connector auf Linux       /dev/ttyUSB0}
		\PYG{c+c1}{\PYGZsh{} Mit USB Connector auf Windows     COM4}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{sensor} \PYG{o}{=} \PYG{n}{minmb}\PYG{o}{.}\PYG{n}{Instrument}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}/dev/ttyAMA0\PYGZsq{}}\PYG{p}{,}
		\PYG{n}{mb\PYGZus{}address}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Make an \PYGZdq{}instrument\PYGZdq{} object called sensor (port name, slave address (in decimal))}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{sensor}\PYG{o}{.}\PYG{n}{serial}\PYG{o}{.}\PYG{n}{baudrate} \PYG{o}{=} \PYG{n}{baud\PYGZus{}rate}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{sensor}\PYG{o}{.}\PYG{n}{serial}\PYG{o}{.}\PYG{n}{bytesize} \PYG{o}{=} \PYG{l+m+mi}{8}  \PYG{c+c1}{\PYGZsh{} Number of data bits to be requested}
		
		\PYG{k}{if} \PYG{n}{parity} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}even\PYGZdq{}}\PYG{p}{:}  \PYG{c+c1}{\PYGZsh{} Parity Setting can be ODD, EVEN or NONE}
			\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{sensor}\PYG{o}{.}\PYG{n}{serial}\PYG{o}{.}\PYG{n}{parity} \PYG{o}{=} \PYG{n}{minmb}\PYG{o}{.}\PYG{n}{serial}\PYG{o}{.}\PYG{n}{PARITY\PYGZus{}EVEN}
		\PYG{k}{elif} \PYG{n}{parity} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}odd\PYGZdq{}}\PYG{p}{:}
			\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{sensor}\PYG{o}{.}\PYG{n}{serial}\PYG{o}{.}\PYG{n}{parity} \PYG{o}{=} \PYG{n}{minmb}\PYG{o}{.}\PYG{n}{serial}\PYG{o}{.}\PYG{n}{PARITY\PYGZus{}ODD}
		\PYG{k}{else}\PYG{p}{:}
			\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{sensor}\PYG{o}{.}\PYG{n}{serial}\PYG{o}{.}\PYG{n}{parity} \PYG{o}{=} \PYG{n}{minmb}\PYG{o}{.}\PYG{n}{serial}\PYG{o}{.}\PYG{n}{PARITY\PYGZus{}NONE}
		
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{sensor}\PYG{o}{.}\PYG{n}{serial}\PYG{o}{.}\PYG{n}{stopbits} \PYG{o}{=} \PYG{n}{stop\PYGZus{}bits}  \PYG{c+c1}{\PYGZsh{} Number of stop bits}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{sensor}\PYG{o}{.}\PYG{n}{serial}\PYG{o}{.}\PYG{n}{timeout} \PYG{o}{=} \PYG{l+m+mf}{0.5}  \PYG{c+c1}{\PYGZsh{} Timeout time in seconds}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{sensor}\PYG{o}{.}\PYG{n}{mode} \PYG{o}{=} \PYG{n}{minmb}\PYG{o}{.}\PYG{n}{MODE\PYGZus{}RTU}  \PYG{c+c1}{\PYGZsh{} Mode to be used (RTU or ascii mode)}
		
		\PYG{c+c1}{\PYGZsh{} Good practice to clean up before and after each execution}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{sensor}\PYG{o}{.}\PYG{n}{clear\PYGZus{}buffers\PYGZus{}before\PYGZus{}each\PYGZus{}transaction} \PYG{o}{=} \PYG{k+kc}{True}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{sensor}\PYG{o}{.}\PYG{n}{close\PYGZus{}port\PYGZus{}after\PYGZus{}each\PYGZus{}call} \PYG{o}{=} \PYG{k+kc}{True}
	
	\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}data\PYGZus{}from\PYGZus{}modbus}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{):}
		\PYG{k}{try}\PYG{p}{:}
			\PYG{n}{fetched\PYGZus{}data} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{sensor}\PYG{o}{.}\PYG{n}{read\PYGZus{}registers}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{register}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{function\PYGZus{}code}\PYG{p}{)}
			
			\PYG{c+c1}{\PYGZsh{} fetched\PYGZus{}data\PYGZus{}scaled = \PYGZdq{}\PYGZdq{}}
			\PYG{c+c1}{\PYGZsh{} if self.scaling == 0:  \PYGZsh{} scaling 0 \PYGZhy{}\PYGZhy{}\PYGZgt{} the value is a bool}
			\PYG{c+c1}{\PYGZsh{}     if fetched\PYGZus{}data[0] == 0:}
			\PYG{c+c1}{\PYGZsh{}         fetched\PYGZus{}data\PYGZus{}scaled = False}
			\PYG{c+c1}{\PYGZsh{}     else:}
			\PYG{c+c1}{\PYGZsh{}         fetched\PYGZus{}data\PYGZus{}scaled = True}
			\PYG{c+c1}{\PYGZsh{} else:}
			\PYG{n}{fetched\PYGZus{}data\PYGZus{}scaled} \PYG{o}{=} \PYG{n+nb}{round}\PYG{p}{((}\PYG{n}{fetched\PYGZus{}data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{*} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{scaling}\PYG{p}{),} \PYG{l+m+mi}{1}\PYG{p}{)}
			\PYG{c+c1}{\PYGZsh{} fetched\PYGZus{}data\PYGZus{}scaled = str(fetched\PYGZus{}data\PYGZus{}scaled)}
			\PYG{k}{return} \PYG{n}{fetched\PYGZus{}data\PYGZus{}scaled}
		
		\PYG{k}{except} \PYG{n+ne}{Exception} \PYG{k}{as} \PYG{n}{e}\PYG{p}{:}
			\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Err: \PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{e}\PYG{p}{))}
			\PYG{n}{fetched\PYGZus{}data\PYGZus{}scaled} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}N/A\PYGZdq{}}
			\PYG{k}{return} \PYG{n}{fetched\PYGZus{}data\PYGZus{}scaled}
\end{Verbatim}
