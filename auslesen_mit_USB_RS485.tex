\label{auslesen_rlt_parameter}

Um über die \gls{gls_rs485} Schnittstelle mit \gls{gls_minimalmodbus} Daten auszulesen wird ein separater \gls{gls_thread} erstellt. In diesem wird die \enquote{data\_refresh} Funktion ausgeführt. Diese Funktion kann nicht im Hauptthread laufen, da \gls{gls_ctk} den Hauptthread blockiert. Außerdem wird durch den Einsatz von Threads die Last besser verteilt. Beim Erstellen des Threads wird angegeben, dass die \enquote{data\_refresh} Funktion darin ausgeführt wird. Als Parameter erhält diese die \gls{gls_ctk} \enquote{app} Instanz (siehe Kapitel  \ref{tkintercode}). Außerdem deklariert man ihn als \gls{gls_daemon} \gls{gls_thread}. Dadurch kann das Programm terminieren, auch wenn der \gls{gls_daemon} \gls{gls_thread} noch nicht geendet hat.

\begin{pythoncode}
def data_threading(app):
	t1 = Thread(target=data_refresh, kwargs={'app': app}, daemon=True)
	t1.start()
\end{pythoncode}

In diesem \gls{gls_thread} werden periodisch, jeweils in 0,4 Sekunden Abständen die Daten der Sensoren erneuert. Die Sensoren sind in den Measurements gespeichert. Es werden alle \enquote{Page} Instanzen und darin alle \enquote{Measurement} Instanzen iteriert und die \enquote{run\_calculation( )} Methode aufgerufen. Diese liefert den ausgelesenen Wert zurück, der dann auf der \acs{gui} an der entsprechenden Stelle umgeändert wird. Dies passiert mit der \enquote{set\_page\_text\_at} Methode der \enquote{App} Klasse (siehe Kapitel \ref{tkintercode}). \newline Mit dieser Implementierung werden kontinuierlich alle Werte ausgelesen und erneuert. Dadurch können beim Wechseln der Seite sofort die zuletzt verfügbaren Messwerte angesehen werden. Würde immer nur die aktuelle Seite geladen werden, wäre das Programm zwar etwas effizienter, aber beim Umschalten der Seite zeigen die Messwerte überall einen Fehlercode an, bis die Daten erneuert werden. 

\begin{pythoncode}
def data_refresh(app):
	while True:
		page_counter = 0
		for page in all_pages:
			measurement_counter = 0
			for measurement in page.measurements:
				value = measurement.run_calculation()
				app.set_page_text_at(page_counter, measurement_counter, measurement.description, value)
				measurement_counter += 1
			page_counter += 1
		
		time.sleep(0.4)
\end{pythoncode}

Die \enquote{Sensor} Instanzen lesen dann mithilfe von \gls{gls_minimalmodbus} die Register der am Bus angeschlossenen Geräte aus. Im Konstruktor der Sensor Instanzen wird die Kommunikation aufgesetzt. Es gibt eine Vielzahl von Parametern, die aus den Konfigurationsdateien ausgelesen werden, welche hier beschrieben werden (vgl. Kapitel \ref{json_config_files}). Damit wird eine \enquote{Instrument} Instanz erstellt, welche mit den Parametern konfiguriert wird. Zuletzt werden noch zwei Optionen auf True gesetzt. Zum Einen wird \enquote{clear\_buffers\_before\_each\_transaction} aktiviert. Dadurch werden Lese- und Schreibpuffer nach jedem Zugriff geleert. Dies verhindert das Auftreten mancher Fehler. Außerdem wird \enquote{close\_port\_after\_each\_call} aktiviert, damit der Port nach jedem Zugriff geschlossen wird. Wenn das Programm terminiert, wird der \gls{gls_thread} auch terminiert. Wenn der Port nun nach jedem Zugriff geschlossen wird, werden somit weitere Fehler verhindert.

\begin{pythoncode}
class Sensor():
	def __init__(self, baud_rate, mb_address, parity, stop_bits, scaling, register, function_code, zero_based):
		self.sensor = minmb.Instrument('/dev/ttyAMA0', mb_address)
		self.sensor.serial.baudrate = baud_rate
		self.sensor.serial.bytesize = 8
		
		if parity == "even":  # ODD, EVEN oder NONE
			self.sensor.serial.parity = minmb.serial.PARITY_EVEN
		elif parity == "odd":
			self.sensor.serial.parity = minmb.serial.PARITY_ODD
		else:
			self.sensor.serial.parity = minmb.serial.PARITY_NONE
		
		self.sensor.serial.stopbits = stop_bits
		self.sensor.serial.timeout = 0.5
		self.sensor.mode = minmb.MODE_RTU
		
		self.sensor.clear_buffers_before_each_transaction = True
		self.sensor.close_port_after_each_call = True
\end{pythoncode}

Beim Erstellen der \enquote{Instrument} Instanz wird als erster Parameter angegeben, an welchem Port am Raspberry Pi der Adapter angeschlossen ist bzw. über welchen Port die Kommunikation stattfindet. Dabei muss je nach Plattform und Adapterart ein anderer Gerätestring angegeben werden:
\begin{itemize}
\item \textbf{COM4:} Damit kann auf Windows die Kommunikation mit Modbus über einen USB Connector aufgesetzt werden. Die Nummer am Ende der Zeichenkette, ist dabei bei jedem PC / Port unterschiedlich und wird intern vergeben. Man muss diese vorher im Gerätemanager nachschauen und kann dann die entsprechende Nummer verwenden. Hier fand es seinen Einsatz insbesondere bei den anfänglichen Ausleseversuchen und den ersten Programmversionen.
\item \textbf{/dev/ttyUSB0:} Damit kann auf Linux die Kommunikation mit Modbus über einen USB Connector aufgesetzt werden. Benutzt wurde dieses beim Testen des Programms auf dem Raspberry Pi, als der erste \gls{gls_rs485} Adapter noch nicht geliefert war bzw. nicht funktionierte.
\item \textbf{/dev/ttyAMA0:} Damit kann auf Linux über die \acf{uart} Pins, also genauer gesagt Pin 8 (TX) und Pin 10 (RX) kommuniziert werden. Im finalen Programm wird das verwendet, da dieses auf dem Raspberry Pi läuft und über die \acs{uart} Pins kommuniziert. Die Pins sind dabei über einen funktionierenden \gls{gls_rs485} Adapter als Zwischenstück an dem Bussystem angeschlossen.
\end{itemize}

\vfill

\label{get_data_from_modbus}
In der \enquote{get\_data\_from\_modbus} Methode, welche auch Teil der \enquote{Sensor} Klasse ist, wird dann das entsprechende Register mithilfe der von \gls{gls_minimalmodbus} bereitgestellten \enquote{read\_registers} Funktion ausgelesen. In der Parameterliste gibt man die Registernummer, die Anzahl an auszulesender Register und den Modbus Function Code an. Der ausgelesene Wert wird dann entsprechend der in der Konfigurationsdatei angegebenen Skalierung angepasst und zurückgeliefert. Diese Methode wird innerhalb der konfigurierbaren Funktionen der \enquote{modbus\_functions} Datei aufgerufen (vgl. Kapitel \ref{python_functions}).

\begin{pythoncode}
class Sensor():
	def get_data_from_modbus(self):
		try:
			fetched_data = self.sensor.read_registers(self.register, 1, self.function_code)
			fetched_data_scaled = round((fetched_data[0] * self.scaling), 1)
			return fetched_data_scaled
		
		except Exception as e:
			print("Err: ", str(e))
			return "N/A"
\end{pythoncode}

In der \enquote{run\_calculation\_function} Methode der \enquote{Measurement} Instanz wird die in der Konfigurationsdatei angegebene Funktion ausgewählt. Wenn \enquote{standard} eingelesen wurde, wird die Standard Funktion ausgeführt. Ansonsten wird mit \enquote{hasattr} überprüft, ob innerhalb der \enquote{modbus\_functions} Datei die angegebene Funktion existiert. Wenn diese existiert, wird mit \enquote{getattr} ein Funktionszeiger erstellt. Mit diesem Zeiger wird dann die entsprechende Funktion ausgeführt. Welche Funktionen vorhanden sind wird in Kapitel \ref{python_functions} beschrieben. 

\begin{pythoncode}
class Measurement():
	def run_calculation(self):
		try:
			if self.python_function == "standard":
				self.value = str(modbus_functions.standard(self.sensors, self.additional_info)) + " " + self.unit
			elif (hasattr(modbus_functions, self.python_function)):
				calc_function = getattr(modbus_functions, self.python_function)
				self.value = str(calc_function(self.sensors, self.additional_info))
			else:
				self.value = "python function was invalid"
		
			return self.value
		except Exception as e:
			print("Err: ", e)
\end{pythoncode}