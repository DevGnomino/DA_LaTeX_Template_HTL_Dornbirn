\label{auslesen_rlt_parameter}

Um über die RS485 Schnittstelle mit minimalmodbus Daten auszulesen wird ein separater Thread erstellt. In diesem wird die \enquote{data\_refresh} Funktion ausgeführt. Diese Funktion kann nicht im Hauptthread laufen, da customtkinter den Hauptthread blockiert.

\begin{pythoncode}
def data_threading(app):
	# Funktion zum Starten des Datenbeschaffungsthreads
	global t1
	t1 = Thread(target=data_refresh, kwargs={'app': app}, daemon=True)
	t1.start()
\end{pythoncode}

In diesem Thread werden periodisch, jeweils in 0,4 Sekunden Abständen die Daten der Sensoren erneuert. Die Sensoren sind in den Measurements gespeichert. Es werden alle Seiten und darin alle Measurements iteriert und die \enquote{run\_calculation\_function} Methode aufgerufen. Diese liefert den ausgelesenen Wert zurück, der dann auf der \acs{gui} an der entsprechenden Stelle umgeändert wird.

\begin{pythoncode}
def data_refresh(app):
	global stop_thread
	stop_thread = False
	while stop_thread == False:
		# This looks better, because all pages are already loaded; but it might be more costly
		page_counter = 0
		for page in all_pages:
			measurement_counter = 0
			for measurement in page.measurements:
				value = measurement.run_calculation_function()
				app.set_page_text_at(page_counter, measurement_counter, measurement.description, value)
				measurement_counter += 1
			page_counter += 1
		
		time.sleep(0.4)
\end{pythoncode}

Die Sensorobjekte lesen dann mithilfe von minimalmodbus die Register der am Bus angeschlossenen Geräte aus. Im Konstruktor des Sensorobjekts wird die Kommunikation aufgesetzt. Es gibt eine Vielzahl von Parametern, die aus den Konfigurationsdateien ausgelesen werden, welche hier beschrieben werden (link auf damios chapter zu config aufbau). Damit wird ein sogenanntes Instrument Objekt erstellt, welches mit den Parametern konfiguriert wird.

\begin{pythoncode}
CONFIG_PATH = '/home/pi/Documents/RLT_Config/'
DEVICES_CONFIG_PATH = '/home/pi/Documents/RLT_Config/devices/'

class Sensor():
	def __init__(self, baud_rate, mb_address, parity, stop_bits, scaling, register, function_code, zero_based):
        # Mit USB Connector auf Linux       /dev/ttyUSB0
		# Mit USB Connector auf Windows     COM4
		# Über TX (8) und RX (10) Pins      /dev/ttyAMA0
		self.sensor = minmb.Instrument('/dev/ttyAMA0', mb_address)
		self.sensor.serial.baudrate = baud_rate
		self.sensor.serial.bytesize = 8
		
		if parity == "even":  # ODD, EVEN oder NONE
			self.sensor.serial.parity = minmb.serial.PARITY_EVEN
		elif parity == "odd":
			self.sensor.serial.parity = minmb.serial.PARITY_ODD
		else:
			self.sensor.serial.parity = minmb.serial.PARITY_NONE
		
		self.sensor.serial.stopbits = stop_bits
		self.sensor.serial.timeout = 0.5
		self.sensor.mode = minmb.MODE_RTU
		
		self.sensor.clear_buffers_before_each_transaction = True
		self.sensor.close_port_after_each_call = True
\end{pythoncode}

\label{get_data_from_modbus}
In der \enquote{get\_data\_from\_modbus} Funktion, welche auch Teil der Sensorklasse ist, wird dann das entsprechende Register mithilfe der von minimalmodbus bereitgestellten \enquote{read\_register} Funktion ausgelesen. In der Parameterliste gibt man die Registernummer, die Anzahl an auszulesender Register und der Modbus Function Code an. Der ausgelesene Wert wird dann entsprechend der in der Konfigurationsdatei angegebenen Skalierung angepasst und zurückgeliefert. Diese Methode wird innerhalb der konfigurierbaren Funktionen  der \enquote{modbus\_functions} Datei aufgerufen.

\begin{pythoncode}
class Sensor():
	def get_data_from_modbus(self):
		try:
			fetched_data = self.sensor.read_registers(self.register, 1, self.function_code)
			fetched_data_scaled = round((fetched_data[0] * self.scaling), 1)
			return fetched_data_scaled
		
		except Exception as e:
			print("Err: ", str(e))
			return "N/A"
\end{pythoncode}

In der \enquote{run\_calculation\_function} Methode wird die in der Konfigurationsdatei angegebene Funktion ausgewählt. Wenn \enquote{standard} eingelesen wurde, wird die Standard Funktion ausgeführt. Ansonsten wird mit \enquote{hasattr} überprüft, ob innerhalb der \enquote{modbus\_functions} Datei die angegebene Funktion existiert. Wenn diese existiert, wird mit \enquote{getattr} ein Funktionszeiger erstellt. Mit diesem Zeiger wird dann die entsprechende Funktion ausgeführt. Welche Funktionen vorhanden sind wird hier beschrieben (link auf python\_functions). 

\begin{pythoncode}
class Measurement():
	def run_calculation_function(self):
		try:
			if self.python_function == "standard":
				self.value = str(modbus_functions.standard(self.sensors, self.additional_info)) + " " + self.unit
			elif (hasattr(modbus_functions, self.python_function)):
				calc_function = getattr(modbus_functions, self.python_function)
				self.value = str(calc_function(self.sensors, self.additional_info))
			else:
				self.value = "python function was invalid"
		
			return self.value
		except Exception as e:
			print("Err: ", e)
\end{pythoncode}